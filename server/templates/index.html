<!DOCTYPE html>
<html>
    <head>
        <title>NMEA Viewer (filtré)</title>
        <meta charset="utf-8">
        <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
        <style>
        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --box-color: #1e1e1e;
            --highlight-gga: #00bcd4;
            --highlight-rmc: #4caf50;
            --highlight-gll: #ff9800;
            --border-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #90caf9;
        }
        
        h2 {
            text-align: center;
            color: #90caf0;
        }

        .NMEA {
            background-color: var(--box-color);
            border: 1px solid var(--border-color);
            padding: 1rem;
            margin: 1rem auto;
            max-width: 800px;
            box-shadow: 0 0 10px rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        .CalculResult {
            max-width: 800px;
            margin: 1rem auto;
            background: var(--box-color);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 0 10px rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .CalculResult p {
            font-size: 1.2rem;
            font-weight: 500;
            padding: 0.5rem;
            margin: 0;
        }

        /* Couleurs par type de trame */
        .gga {
            border-left-color: var(--highlight-gga);
            background-color: rgba(0, 188, 212, 0.1);
        }
        .rmc {
            border-left-color: var(--highlight-rmc);
            background-color: rgba(76, 175, 80, 0.1);
        }
        .gll {
            border-left-color: var(--highlight-gll);
            background-color: rgba(255, 152, 0, 0.1);
        }
        .defaut {
            border-left: 5px solid #555;
            background-color: #1a1a1a;
        }
        
        object {
            width: 100%;
            height: 100px;
            border: none;
            background-color: #1a1a1a;
            color: var(--text-color);
        }

        @media screen and (max-width: 600px) {
            .CalculResult p {
                font-size: 1rem;
            }

            h1 {
                font-size: 1.2rem;
            }
        }
    </style>
    
<!-- ✅ Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<!-- ✅ Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    </head>
    <body>
        <h1>NMEA Viewer</h1>
        <div class="NMEA" style="font-family: monospace;">
          <strong>Types de trames reçues :</strong>
          <p id="listeTrames"></p>
        </div>
        <div class="NMEA" style="font-family: monospace;">
          <strong>Trame reçue :</strong>
          <p id="gpsMessage"></p>
        </div>
        <div class="CalculResult">
            <p class="defaut" id="date"></p>
            <p class="defaut" id="heure"></p>
            <p class="defaut" id="latitude"></p>
            <p class="defaut" id="longitude"></p>
            <p class="defaut" id="altitude"></p>
            <p class="defaut" id="vitesse"></p>
            <p class="defaut" id="cap"></p>
            <p class="defaut" id="heading"></p>
        </div>
        <!-- ✅ Carte Leaflet -->
        <div class="NMEA">
            <h2>Position sur la carte</h2>
            <div id="map" style="height: 400px; width: 100%; border-radius: 8px;"></div>
        </div>

        <script>
            const socket = io();

        const trameTypes = new Set();
        const pDate = document.getElementById('date');
        const pHeure = document.getElementById('heure');
        const pLat = document.getElementById('latitude');
        const pLong = document.getElementById('longitude');
        const pAlt = document.getElementById('altitude');
        const pVitesse = document.getElementById('vitesse');
        const pCap = document.getElementById('cap');
        const pHeading = document.getElementById('heading');
        
        // ✅ Initialiser la carte Leaflet
        let map = L.map('map').setView([48.0, 1.0], 6);  // Position et zoom par défaut
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
        }).addTo(map);

        let marker = null;
        let path = [];
        let polyline = L.polyline([], { color: 'red' }).addTo(map);
        
        function updateMapFromParts(parts, latIndex, latDirIndex, lonIndex, lonDirIndex) {
            const rawLat = parseFloat(parts[latIndex]);
            const latDir = parts[latDirIndex];
            const rawLon = parseFloat(parts[lonIndex]);
            const lonDir = parts[lonDirIndex];

            if (isNaN(rawLat) || isNaN(rawLon)) return;

            const latDD = (Math.floor(rawLat / 100) + (rawLat % 100) / 60) * (latDir === 'S' ? -1 : 1);
            const lonDD = (Math.floor(rawLon / 100) + (rawLon % 100) / 60) * (lonDir === 'W' ? -1 : 1);

            const latlng = [latDD, lonDD];

            if (marker) {
                marker.setLatLng(latlng);
            } else {
                marker = L.marker(latlng).addTo(map);
            }

            path.push(latlng);
            polyline.setLatLngs(path);
            map.setView(latlng, map.getZoom());
        }

        socket.on('nmea_data', function(data) {
            document.getElementById('gpsMessage').textContent = data;
        
            const parts = data.split(',');
        
            //Liste des trames reçues
            const trameId = parts[0]; // ex: $GPGGA, $GPRMC, etc.
                if (!trameTypes.has(trameId)) {
                    trameTypes.add(trameId);
                    document.getElementById('listeTrames').textContent = Array.from(trameTypes).sort().join(', ');
                }
            
            // Conversion de la latitude au format NN° NN,NNN' N/S
            function convertDMtoDMS_Lat(value, direction) {
                if (isNaN(value)) return "";
                const degrees = Math.floor(value / 100);
                const minutes = value - degrees * 100;
                return myDegLat.format(degrees) + `° ` + myMin.format(minutes) + ` ${direction}`;
            }
            
            // Conversion de la longitude au format NNN° NN,NNN' N/S
            function convertDMtoDMS_Lon(value, direction) {
                if (isNaN(value)) return "";
                const degrees = Math.floor(value / 100);
                const minutes = value - degrees * 100;
                return myDegLon.format(degrees) + `° ` + myMin.format(minutes) + ` ${direction}`;
            }
            // RMC Parser  $GPRMC,193715,A,4805.81126,N,00142.52088,W,000.0,,020725,000.8,E,A*20
            function parseRMC(parts) {
                if (parts[2] !== 'A') return null;
                heure = parts[1].match(/.{1,2}/g);
                jour = parts[9].match(/.{1,2}/g);
                return {
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `,
                    lat: convertDMtoDMS_Lat(parseFloat(parts[3]), parts[4]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[5]), parts[6]),
                    speed: (parseFloat(parts[7]) * 1.852).toFixed(2) + " km/h",
                    date: jour[0] + `/` + jour[1] + `/20` + jour[2]
                };
            }
            // GGA Parser
            function parseGGA(parts) {
                if (parts[6] === '0') return null;
                heure = parts[1].match(/.{1,2}/g);
                return {
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `,
                    lat: convertDMtoDMS_Lat(parseFloat(parts[2]), parts[3]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[4]), parts[5]),
                    alt: parts[9] + " " + parts[10]
                };
            }
            //GLL Parser 
            function parseGLL(parts) {
                heure = parts[5].match(/.{1,2}/g);
                return {
                    lat: convertDMtoDMS_Lat(parseFloat(parts[1]), parts[2]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[3]), parts[4]),
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `
                };
            }
            //VTG Parser
            function parseVTG(parts) {
                return {
                    cap: parts[1] + "° True"
                };
            }
            //HDT Parser
            function parseHDT(parts) {
                return {
                    heading: parts[1] + "° True"
                };
            }
            /* To Do: Parser MDA, MMB, XDR, HDG, HDT
            
            */
            var myDegLat = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 2, 
                minimumFractionDigits: 0 
            });
            
            var myDegLon = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 3, 
                minimumFractionDigits: 0 
            });
            
            var myMin = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 2, 
                minimumFractionDigits: 3 
            });
            
            function clearHighlightClasses(...elements) {
                elements.forEach(el => {
                    el.classList.remove('gga', 'rmc', 'gll', 'defaut');
                });
            }
                        
            if (data.substring(3,6) === 'RMC') {
                clearHighlightClasses(pDate, pHeure, pLat, pLong, pVitesse);
                pDate.classList.add('rmc');
                pHeure.classList.add('rmc');
                pLat.classList.add('rmc');
                pLong.classList.add('rmc');
                pVitesse.classList.add('rmc');
                const parsed = parseRMC(parts);
                if (parsed) {
                    // Mise à jour des champs texte...
                    pDate.textContent = "Date : " + parsed.date;
                    pHeure.textContent = "Heure UTC : " + parsed.time;
                    pLat.textContent = "Latitude : " + parsed.lat;
                    pLong.textContent = "Longitude : " + parsed.lon;
                    pVitesse.textContent = "Vitesse : " + parsed.speed;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 3, 4, 5, 6); // lat, latDir, lon, lonDir
                }
                } else if (data.substring(3,6) === 'GGA') {
                clearHighlightClasses(pHeure, pLat, pLong, pAlt);
                pHeure.classList.add('gga');
                pLat.classList.add('gga');
                pLong.classList.add('gga');
                pAlt.classList.add('gga');
                const parsed = parseGGA(parts);
                if (parsed) {
                    pHeure.textContent = "Heure UTC : " + parsed.time;
                    pLat.textContent = "Latitude : " + parsed.lat;
                    pLong.textContent = "Longitude : " + parsed.lon;
                    pAlt.textContent = "Altitude : " + parsed.alt;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 2, 3, 4, 5);
                }
                } else if (data.substring(3,6) === 'GLL') {
                clearHighlightClasses(pHeure, pLat, pLong);
                pHeure.classList.add('gll');
                pLat.classList.add('gll');
                pLong.classList.add('gll');
                const parsed = parseGLL(parts);
                if (parsed) {
                    pHeure.textContent = "Heure UTC : " + parsed.time;
                    pLat.textContent = "Latitude : " + parsed.lat;
                    pLong.textContent = "Longitude : " + parsed.lon;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 1, 2, 3, 4);
                }
                } else if (data.substring(3,6) === 'VTG') {
                const parsed = parseVTG(parts);
                if (parsed) {
                    document.getElementById('cap').textContent = "Route fond : " + parsed.cap;
                }
                } else if (data.substring(3,6) === 'HDT') {
                const parsed = parseHDT(parts);
                if (parsed) {
                    document.getElementById('heading').textContent = "Cap : " + parsed.heading;
                }
                };
        });
    </script>
  </body>
</html>


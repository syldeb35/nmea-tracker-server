<!DOCTYPE html>
<html>
    <head>
        <title>NMEA Viewer (filtré)</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" type="image/svg+xml" href="favicon.svg">
        <link rel="icon" type="image/png" sizes="32x32" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZDEiIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMTk3NmQyO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiMxMjU2YTM7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICA8Y2lyY2xlIGN4PSIxNiIgY3k9IjE2IiByPSIxNSIgZmlsbD0idXJsKCNncmFkMSkiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+CiAgPHBhdGggZD0iTTE2IDYgTDIwIDE0IEwxNiAxMiBMMTIgMTQgWiIgZmlsbD0iI2ZmZiIvPgogIDxwYXRoIGQ9Ik04IDE4IEwyNCAxOCIgc3Ryb2tlPSIjZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxwYXRoIGQ9Ik0xMCAyMiBMMjIgMjIiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxjaXJjbGUgY3g9IjE2IiBjeT0iMjYiIHI9IjEuNSIgZmlsbD0iI2ZmZiIvPgo8L3N2Zz4K">
        <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
        <style>
        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --box-color: #1e1e1e;
            --highlight-gga: #00bcd4;
            --highlight-rmc: #4caf50;
            --highlight-gll: #ff9800;
            --highlight-ais: #e91e63;
            --border-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #90caf9;
        }
        
        h2 {
            text-align: center;
            color: #90caf0;
        }

        .NMEA {
            background-color: var(--box-color);
            border: 1px solid var(--border-color);
            padding: 1rem;
            margin: 1rem auto;
            max-width: 800px;
            box-shadow: 0 0 10px rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        .CalculResult {
            max-width: 800px;
            margin: 1rem auto;
            background: var(--box-color);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 0 10px rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .CalculResult p {
            font-size: 1.2rem;
            font-weight: 500;
            padding: 0.5rem;
            margin: 0;
        }

        /* Couleurs par type de trame */
        .gga {
            border-left-color: var(--highlight-gga);
            background-color: rgba(0, 188, 212, 0.1);
        }
        .rmc {
            border-left-color: var(--highlight-rmc);
            background-color: rgba(76, 175, 80, 0.1);
        }
        .gll {
            border-left-color: var(--highlight-gll);
            background-color: rgba(255, 152, 0, 0.1);
        }
        .ais {
            border-left-color: var(--highlight-ais);
            background-color: rgba(233, 30, 99, 0.1);
        }
        .defaut {
            border-left: 5px solid #555;
            background-color: #1a1a1a;
        }
        
        object {
            width: 100%;
            height: 100px;
            border: none;
            background-color: #1a1a1a;
            color: var(--text-color);
        }
        
        /* ✅ Style pour les icônes de navires AIS */
        .ship-icon {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        @media screen and (max-width: 600px) {
            .CalculResult p {
                font-size: 1rem;
            }

            h1 {
                font-size: 1.2rem;
            }
        }
    </style>
    
<!-- ✅ Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<!-- ✅ Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    </head>
    <body>
        <h1>NMEA Viewer</h1>
        <div class="NMEA" style="font-family: monospace;">
          <strong>Types de trames reçues :</strong>
          <p id="listeTrames"></p>
        </div>
        <div class="NMEA" style="font-family: monospace;">
          <strong>Trame reçue :</strong>
          <p id="gpsMessage"></p>
        </div>
        <div class="CalculResult">
            <p class="defaut" id="date"></p>
            <p class="defaut" id="heure"></p>
            <p class="defaut" id="latitude"></p>
            <p class="defaut" id="longitude"></p>
            <p class="defaut" id="altitude"></p>
            <p class="defaut" id="vitesse"></p>
            <p class="defaut" id="cap"></p>
            <p class="defaut" id="heading"></p>
        </div>
        <!-- ✅ Section AIS -->
        <div class="NMEA">
            <h2>Données AIS (Navires à proximité)</h2>
            <div class="CalculResult">
                <p class="defaut" id="ais-mmsi"></p>
                <p class="defaut" id="ais-nom"></p>
                <p class="defaut" id="ais-position"></p>
                <p class="defaut" id="ais-vitesse"></p>
                <p class="defaut" id="ais-cap"></p>
                <p class="defaut" id="ais-type"></p>
                <p class="defaut" id="ais-destination"></p>
                <p class="defaut" id="ais-eta"></p>
            </div>
        </div>
        <!-- ✅ Carte Leaflet -->
        <div class="NMEA">
            <h2>Position sur la carte</h2>
            <div id="map" style="height: 400px; width: 100%; border-radius: 8px;"></div>
        </div>

        <script>
            const socket = io();

        const trameTypes = new Set();
        const pDate = document.getElementById('date');
        const pHeure = document.getElementById('heure');
        const pLat = document.getElementById('latitude');
        const pLong = document.getElementById('longitude');
        const pAlt = document.getElementById('altitude');
        const pVitesse = document.getElementById('vitesse');
        const pCap = document.getElementById('cap');
        const pHeading = document.getElementById('heading');
        
        // ✅ Éléments AIS
        const pAisMmsi = document.getElementById('ais-mmsi');
        const pAisNom = document.getElementById('ais-nom');
        const pAisPosition = document.getElementById('ais-position');
        const pAisVitesse = document.getElementById('ais-vitesse');
        const pAisCap = document.getElementById('ais-cap');
        const pAisType = document.getElementById('ais-type');
        const pAisDestination = document.getElementById('ais-destination');
        const pAisEta = document.getElementById('ais-eta');
        
        // ✅ Initialiser la carte Leaflet
        let map = L.map('map').setView([48.0, 1.0], 6);  // Position et zoom par défaut
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
        }).addTo(map);

        let marker = null;
        let path = [];
        let polyline = L.polyline([], { color: 'red' }).addTo(map);
        
        function updateMapFromParts(parts, latIndex, latDirIndex, lonIndex, lonDirIndex) {
            const rawLat = parseFloat(parts[latIndex]);
            const latDir = parts[latDirIndex];
            const rawLon = parseFloat(parts[lonIndex]);
            const lonDir = parts[lonDirIndex];

            if (isNaN(rawLat) || isNaN(rawLon)) return;

            const latDD = (Math.floor(rawLat / 100) + (rawLat % 100) / 60) * (latDir === 'S' ? -1 : 1);
            const lonDD = (Math.floor(rawLon / 100) + (rawLon % 100) / 60) * (lonDir === 'W' ? -1 : 1);

            const latlng = [latDD, lonDD];

            if (marker) {
                marker.setLatLng(latlng);
            } else {
                marker = L.marker(latlng).addTo(map);
            }

            path.push(latlng);
            polyline.setLatLngs(path);
            map.setView(latlng, map.getZoom());
        }

        socket.on('nmea_data', function(data) {
            document.getElementById('gpsMessage').textContent = data;
        
            const parts = data.split(',');
        
            //Liste des trames reçues
            const trameId = parts[0]; // ex: $GPGGA, $GPRMC, etc.
                if (!trameTypes.has(trameId)) {
                    trameTypes.add(trameId);
                    document.getElementById('listeTrames').textContent = Array.from(trameTypes).sort().join(', ');
                }
            
            // Conversion de la latitude au format NN° NN,NNN' N/S
            function convertDMtoDMS_Lat(value, direction) {
                if (isNaN(value)) return "";
                const degrees = Math.floor(value / 100);
                const minutes = value - degrees * 100;
                return myDegLat.format(degrees) + `° ` + myMin.format(minutes) + ` ${direction}`;
            }
            
            // Conversion de la longitude au format NNN° NN,NNN' N/S
            function convertDMtoDMS_Lon(value, direction) {
                if (isNaN(value)) return "";
                const degrees = Math.floor(value / 100);
                const minutes = value - degrees * 100;
                return myDegLon.format(degrees) + `° ` + myMin.format(minutes) + ` ${direction}`;
            }
            // RMC Parser  $GPRMC,193715,A,4805.81126,N,00142.52088,W,000.0,,020725,000.8,E,A*20
            function parseRMC(parts) {
                if (parts[2] !== 'A') return null;
                heure = parts[1].match(/.{1,2}/g);
                jour = parts[9].match(/.{1,2}/g);
                return {
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `,
                    lat: convertDMtoDMS_Lat(parseFloat(parts[3]), parts[4]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[5]), parts[6]),
                    speed: parseFloat(parts[7]).toFixed(2) + " knots <small>(" + (parseFloat(parts[7]) * 1.852).toFixed(2) + " km/h)</small>",
                    date: jour[0] + `/` + jour[1] + `/20` + jour[2]
                };
            }
            // GGA Parser
            function parseGGA(parts) {
                if (parts[6] === '0') return null;
                heure = parts[1].match(/.{1,2}/g);
                return {
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `,
                    lat: convertDMtoDMS_Lat(parseFloat(parts[2]), parts[3]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[4]), parts[5]),
                    alt: parts[9] + " " + parts[10]
                };
            }
            //GLL Parser 
            function parseGLL(parts) {
                heure = parts[5].match(/.{1,2}/g);
                return {
                    lat: convertDMtoDMS_Lat(parseFloat(parts[1]), parts[2]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[3]), parts[4]),
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `
                };
            }
            //VTG Parser
            function parseVTG(parts) {
                return {
                    cap: parts[1] + "° True"
                };
            }
            //HDT Parser
            function parseHDT(parts) {
                return {
                    heading: parts[1] + "° True"
                };
            }
            
            // ✅ AIS Parsers
            // Fonction de décodage 6-bit ASCII pour AIS
            function decode6BitAscii(data, start, length) {
                const chars = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?";
                let result = "";
                for (let i = start; i < start + length && i < data.length; i += 6) {
                    const charCode = parseInt(data.substr(i, 6), 2);
                    if (charCode < chars.length && charCode !== 0) {
                        result += chars[charCode];
                    }
                }
                return result.trim();
            }
            
            // Fonction pour décoder les données AIS encapsulées
            function decodeAisPayload(payload) {
                // Décodage 6-bit vers binaire
                let binaryData = "";
                for (let i = 0; i < payload.length; i++) {
                    let char = payload.charCodeAt(i);
                    if (char >= 48 && char <= 87) { // '0' à 'W'
                        char -= 48;
                    } else if (char >= 96 && char <= 119) { // '`' à 'w'  
                        char -= 56;
                    } else {
                        continue;
                    }
                    binaryData += char.toString(2).padStart(6, '0');
                }
                return binaryData;
            }
            
            // Parser principal AIS
            function parseAIS(parts) {
                try {
                    // Structure trame AIS: !AIVDM,1,1,,B,payload,0*checksum
                    if (parts.length < 6) return null;
                    
                    const payload = parts[5];
                    const binaryData = decodeAisPayload(payload);
                    
                    if (binaryData.length < 8) return null;
                    
                    // Type de message (bits 0-5)
                    const messageType = parseInt(binaryData.substr(0, 6), 2);
                    
                    // MMSI (bits 8-37)
                    const mmsi = parseInt(binaryData.substr(8, 30), 2);
                    
                    let result = {
                        messageType: messageType,
                        mmsi: mmsi.toString()
                    };
                    
                    // Type 1, 2, 3: Position Report
                    if (messageType >= 1 && messageType <= 3 && binaryData.length >= 168) {
                        const navStatus = parseInt(binaryData.substr(38, 4), 2);
                        const rot = parseInt(binaryData.substr(42, 8), 2);
                        const sog = parseInt(binaryData.substr(50, 10), 2) / 10;
                        const lon = parseInt(binaryData.substr(61, 28), 2);
                        const lat = parseInt(binaryData.substr(89, 27), 2);
                        const cog = parseInt(binaryData.substr(116, 12), 2) / 10;
                        const heading = parseInt(binaryData.substr(128, 9), 2);
                        
                        // Conversion coordonnées
                        const longitude = (lon > 134217727) ? (lon - 268435456) / 600000 : lon / 600000;
                        const latitude = (lat > 67108863) ? (lat - 134217728) / 600000 : lat / 600000;
                        
                        result.latitude = latitude.toFixed(6);
                        result.longitude = longitude.toFixed(6);
                        result.sog = sog.toFixed(1);
                        result.cog = cog.toFixed(1);
                        result.heading = heading !== 511 ? heading.toString() : "N/A";
                        result.status = getNavStatus(navStatus);
                    }
                    
                    // Type 5: Static and Voyage Related Data
                    if (messageType === 5 && binaryData.length >= 424) {
                        const vesselName = decode6BitAscii(binaryData, 112, 120).replace(/@/g, '');
                        const shipType = parseInt(binaryData.substr(232, 8), 2);
                        const destination = decode6BitAscii(binaryData, 302, 120).replace(/@/g, '');
                        const etaMonth = parseInt(binaryData.substr(274, 4), 2);
                        const etaDay = parseInt(binaryData.substr(278, 5), 2);
                        const etaHour = parseInt(binaryData.substr(283, 5), 2);
                        const etaMinute = parseInt(binaryData.substr(288, 6), 2);
                        
                        result.vesselName = vesselName;
                        result.shipType = getShipType(shipType);
                        result.destination = destination;
                        if (etaMonth > 0 && etaDay > 0) {
                            result.eta = `${etaDay}/${etaMonth} ${etaHour}:${etaMinute.toString().padStart(2, '0')}`;
                        }
                    }
                    
                    return result;
                } catch (error) {
                    console.log("Erreur parsing AIS:", error);
                    return null;
                }
            }
            
            // Fonction utilitaire pour le statut de navigation
            function getNavStatus(status) {
                const statuses = [
                    "Under way using engine",
                    "At anchor",
                    "Not under command",
                    "Restricted manoeuvrability",
                    "Constrained by her draught",
                    "Moored",
                    "Aground",
                    "Engaged in fishing",
                    "Under way sailing",
                    "Reserved for HSC",
                    "Reserved for WIG",
                    "Reserved",
                    "Reserved",
                    "Reserved",
                    "AIS-SART",
                    "Undefined"
                ];
                return statuses[status] || "Unknown";
            }
            
            // Fonction utilitaire pour le type de navire
            function getShipType(type) {
                if (type >= 20 && type <= 29) return "Wing in ground";
                if (type >= 30 && type <= 39) return "Fishing";
                if (type >= 40 && type <= 49) return "Tug";
                if (type >= 50 && type <= 59) return "Medical";
                if (type >= 60 && type <= 69) return "Passenger";
                if (type >= 70 && type <= 79) return "Cargo";
                if (type >= 80 && type <= 89) return "Tanker";
                if (type >= 90 && type <= 99) return "Other";
                return "Unknown";
            }
            /* To Do: Parser MDA, MMB, XDR, HDG
            ✅ AIS support ajouté (AIVDM/AIVDO)
            */
            var myDegLat = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 2, 
                minimumFractionDigits: 0 
            });
            
            var myDegLon = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 3, 
                minimumFractionDigits: 0 
            });
            
            var myMin = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 2, 
                minimumFractionDigits: 3 
            });
            
            function clearHighlightClasses(...elements) {
                elements.forEach(el => {
                    el.classList.remove('gga', 'rmc', 'gll', 'ais', 'defaut');
                });
            }
                        
            if (data.substring(3,6) === 'RMC') {
                clearHighlightClasses(pDate, pHeure, pLat, pLong, pVitesse);
                pDate.classList.add('rmc');
                pHeure.classList.add('rmc');
                pLat.classList.add('rmc');
                pLong.classList.add('rmc');
                pVitesse.classList.add('rmc');
                const parsed = parseRMC(parts);
                if (parsed) {
                    // Mise à jour des champs texte...
                    pDate.innerHTML = "Date : " + parsed.date;
                    pHeure.innerHTML = "Heure UTC : " + parsed.time;
                    pLat.innerHTML = "Latitude : " + parsed.lat;
                    pLong.innerHTML = "Longitude : " + parsed.lon;
                    pVitesse.innerHTML = "Vitesse : " + parsed.speed;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 3, 4, 5, 6); // lat, latDir, lon, lonDir
                }
                } else if (data.substring(3,6) === 'GGA') {
                clearHighlightClasses(pHeure, pLat, pLong, pAlt);
                pHeure.classList.add('gga');
                pLat.classList.add('gga');
                pLong.classList.add('gga');
                pAlt.classList.add('gga');
                const parsed = parseGGA(parts);
                if (parsed) {
                    pHeure.innerHTML = "Heure UTC : " + parsed.time;
                    pLat.innerHTML = "Latitude : " + parsed.lat;
                    pLong.innerHTML = "Longitude : " + parsed.lon;
                    pAlt.innerHTML = "Altitude : " + parsed.alt;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 2, 3, 4, 5);
                }
                } else if (data.substring(3,6) === 'GLL') {
                clearHighlightClasses(pHeure, pLat, pLong);
                pHeure.classList.add('gll');
                pLat.classList.add('gll');
                pLong.classList.add('gll');
                const parsed = parseGLL(parts);
                if (parsed) {
                    pHeure.innerHTML = "Heure UTC : " + parsed.time;
                    pLat.innerHTML = "Latitude : " + parsed.lat;
                    pLong.innerHTML = "Longitude : " + parsed.lon;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 1, 2, 3, 4);
                }
                } else if (data.substring(3,6) === 'VTG') {
                const parsed = parseVTG(parts);
                if (parsed) {
                    document.getElementById('cap').textContent = "Route fond : " + parsed.cap;
                }
                } else if (data.substring(3,6) === 'HDT') {
                const parsed = parseHDT(parts);
                if (parsed) {
                    document.getElementById('heading').textContent = "Cap : " + parsed.heading;
                }
                } else if (data.substring(1,6) === 'AIVDM' || data.substring(1,6) === 'AIVDO') {
                // ✅ Traitement AIS
                clearHighlightClasses(pAisMmsi, pAisNom, pAisPosition, pAisVitesse, pAisCap, pAisType, pAisDestination, pAisEta);
                pAisMmsi.classList.add('ais');
                pAisNom.classList.add('ais');
                pAisPosition.classList.add('ais');
                pAisVitesse.classList.add('ais');
                pAisCap.classList.add('ais');
                pAisType.classList.add('ais');
                pAisDestination.classList.add('ais');
                pAisEta.classList.add('ais');
                
                const parsed = parseAIS(parts);
                if (parsed) {
                    pAisMmsi.textContent = "MMSI : " + parsed.mmsi;
                    
                    if (parsed.vesselName) {
                        pAisNom.textContent = "Navire : " + parsed.vesselName;
                    }
                    
                    if (parsed.latitude && parsed.longitude) {
                        pAisPosition.textContent = `Position : ${parsed.latitude}°, ${parsed.longitude}°`;
                        
                        // ✅ Afficher le navire sur la carte
                        const lat = parseFloat(parsed.latitude);
                        const lon = parseFloat(parsed.longitude);
                        if (!isNaN(lat) && !isNaN(lon)) {
                            const shipIcon = L.divIcon({
                                className: 'ship-icon',
                                html: `<div style="background: #e91e63; color: white; border-radius: 3px; padding: 2px 5px; font-size: 10px; font-weight: bold;">${parsed.mmsi.slice(-4)}</div>`,
                                iconSize: [50, 20],
                                iconAnchor: [25, 10]
                            });
                            
                            // Supprimer les anciens marqueurs de navires pour ce MMSI
                            map.eachLayer(layer => {
                                if (layer.options && layer.options.mmsi === parsed.mmsi) {
                                    map.removeLayer(layer);
                                }
                            });
                            
                            // Ajouter nouveau marqueur
                            L.marker([lat, lon], { 
                                icon: shipIcon, 
                                mmsi: parsed.mmsi 
                            }).addTo(map).bindPopup(`
                                <b>MMSI:</b> ${parsed.mmsi}<br>
                                ${parsed.vesselName ? `<b>Nom:</b> ${parsed.vesselName}<br>` : ''}
                                ${parsed.sog ? `<b>Vitesse:</b> ${parsed.sog} nœuds<br>` : ''}
                                ${parsed.cog ? `<b>Route:</b> ${parsed.cog}°<br>` : ''}
                                ${parsed.status ? `<b>Statut:</b> ${parsed.status}` : ''}
                            `);
                        }
                    }
                    
                    if (parsed.sog) {
                        pAisVitesse.textContent = "Vitesse AIS : " + parsed.sog + " nœuds (" + (parsed.sog * 1.852).toFixed(1) + " km/h)";
                    }
                    
                    if (parsed.cog) {
                        pAisCap.textContent = "Route AIS : " + parsed.cog + "°";
                    }
                    
                    if (parsed.shipType) {
                        pAisType.textContent = "Type : " + parsed.shipType;
                    }
                    
                    if (parsed.destination) {
                        pAisDestination.textContent = "Destination : " + parsed.destination;
                    }
                    
                    if (parsed.eta) {
                        pAisEta.textContent = "ETA : " + parsed.eta;
                    }
                }
                };
        });
    </script>
  </body>
</html>


<!DOCTYPE html>
<html>
    <head>
        <title>NMEA Viewer (filtré)</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" type="image/svg+xml" href="favicon.svg">
        <link rel="icon" type="image/png" sizes="32x32" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmF            } else if (cleanData.substring(            } else if (cleanData.substring(3,6) === 'VTG') {
                const parsed = parseVTG(parts);
                if (parsed) {
                    document.getElementById('cap').textContent = "Route fond : " + parsed.cap;
                }
            } else if (cleanData.substring(3,6) === 'HDT') {
                const parsed = parseHDT(parts);
                if (parsed) {
                    document.getElementById('heading').textContent = "Cap : " + parsed.heading;
                }
            } else if (cleanData.substring(1,6) === 'AIVDM' || cleanData.substring(1,6) === 'AIVDO') {GA') {
                clearHighlightClasses(pHeure, pLat, pLong, pAlt);
                pHeure.classList.add('gga');
                pLat.classList.add('gga');
                pLong.classList.add('gga');
                pAlt.classList.add('gga');
                const parsed = parseGGA(parts);
                if (parsed) {
                    pHeure.innerHTML = "Heure UTC : " + parsed.time;
                    pLat.innerHTML = "Latitude : " + parsed.lat;
                    pLong.innerHTML = "Longitude : " + parsed.lon;
                    pAlt.innerHTML = "Altitude : " + parsed.alt;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 2, 3, 4, 5);
                }
            } else if (cleanData.substring(3,6) === 'GLL') {hZDEiIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMTk3NmQyO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiMxMjU2YTM7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogIDwvZGVmcz4KICA8Y2lyY2xlIGN4PSIxNiIgY3k9IjE2IiByPSIxNSIgZmlsbD0idXJsKCNncmFkMSkiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+CiAgPHBhdGggZD0iTTE2IDYgTDIwIDE0IEwxNiAxMiBMMTIgMTQgWiIgZmlsbD0iI2ZmZiIvPgogIDxwYXRoIGQ9Ik04IDE4IEwyNCAxOCIgc3Ryb2tlPSIjZmZmIiBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxwYXRoIGQ9Ik0xMCAyMiBMMjIgMjIiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogIDxjaXJjbGUgY3g9IjE2IiBjeT0iMjYiIHI9IjEuNSIgZmlsbD0iI2ZmZiIvPgo8L3N2Zz4K">
        <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
        <style>
        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --box-color: #1e1e1e;
            --highlight-gga: #00bcd4;
            --highlight-rmc: #4caf50;
            --highlight-gll: #ff9800;
            --highlight-ais: #e91e63;
            --border-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #90caf9;
        }
        
        h2 {
            text-align: center;
            color: #90caf0;
        }

        .NMEA {
            background-color: var(--box-color);
            border: 1px solid var(--border-color);
            padding: 1rem;
            margin: 1rem auto;
            max-width: 800px;
            box-shadow: 0 0 10px rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        .CalculResult {
            max-width: 800px;
            margin: 1rem auto;
            background: var(--box-color);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 0 10px rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .CalculResult p {
            font-size: 1.2rem;
            font-weight: 500;
            padding: 0.5rem;
            margin: 0;
        }

        /* Couleurs par type de trame */
        .gga {
            border-left-color: var(--highlight-gga);
            background-color: rgba(0, 188, 212, 0.1);
        }
        .rmc {
            border-left-color: var(--highlight-rmc);
            background-color: rgba(76, 175, 80, 0.1);
        }
        .gll {
            border-left-color: var(--highlight-gll);
            background-color: rgba(255, 152, 0, 0.1);
        }
        .ais {
            border-left-color: var(--highlight-ais);
            background-color: rgba(233, 30, 99, 0.1);
        }
        .defaut {
            border-left: 5px solid #555;
            background-color: #1a1a1a;
        }
        
        object {
            width: 100%;
            height: 100px;
            border: none;
            background-color: #1a1a1a;
            color: var(--text-color);
        }
        
        /* ✅ Style pour les icônes de navires AIS */
        .ship-icon {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        @media screen and (max-width: 600px) {
            .CalculResult p {
                font-size: 1rem;
            }

            h1 {
                font-size: 1.2rem;
            }
        }
    </style>
    
<!-- ✅ Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<!-- ✅ Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    </head>
    <body>
        <h1>NMEA Viewer</h1>
        <div class="NMEA" style="font-family: monospace;">
          <strong>Types de trames reçues :</strong>
          <p id="listeTrames"></p>
        </div>
        <div class="NMEA" style="font-family: monospace;">
          <strong>Trame reçue :</strong>
          <p id="gpsMessage"></p>
        </div>
        <div class="CalculResult">
            <p class="defaut" id="date">Date</p>
            <p class="defaut" id="heure">Hour</p>
            <p class="defaut" id="latitude">Lat</p>
            <p class="defaut" id="longitude">Lon</p>
            <p class="defaut" id="altitude">Alt</p>
            <p class="defaut" id="vitesse">SOG</p>
            <p class="defaut" id="cap">COG</p>
            <p class="defaut" id="heading">Heading</p>
        </div>
        <!-- ✅ Section AIS -->
        <div class="NMEA">
            <h2>Données AIS (Navires à proximité)</h2>
            <div class="CalculResult">
                <p class="defaut" id="ais-mmsi">MMSI : En attente...</p>
                <p class="defaut" id="ais-nom">Navire : En attente...</p>
                <p class="defaut" id="ais-position">Position : En attente...</p>
                <p class="defaut" id="ais-vitesse">Vitesse AIS : En attente...</p>
                <p class="defaut" id="ais-cap">Route AIS : En attente...</p>
                <p class="defaut" id="ais-type">Type : En attente...</p>
                <p class="defaut" id="ais-destination">Destination : En attente...</p>
                <p class="defaut" id="ais-eta">ETA : En attente...</p>
            </div>
        </div>
        <!-- ✅ Carte Leaflet -->
        <div class="NMEA">
            <h2>Position sur la carte</h2>
            <div id="map" style="height: 400px; width: 100%; border-radius: 8px;"></div>
        </div>
        <div class="NMEA">
            <h2>Navires AIS détectés</h2>
            <div id="vessel-list" style="max-height: 200px; overflow-y: auto;">
                <p>Aucun navire détecté pour le moment...</p>
            </div>
        </div>
        <script>
        
        const socket = io();
        const trameTypes = new Set();
        const pDate = document.getElementById('date');
        const pHeure = document.getElementById('heure');
        const pLat = document.getElementById('latitude');
        const pLong = document.getElementById('longitude');
        const pAlt = document.getElementById('altitude');
        const pVitesse = document.getElementById('vitesse');
        const pCap = document.getElementById('cap');
        const pHeading = document.getElementById('heading');
        
        // ✅ Éléments AIS
        const pAisMmsi = document.getElementById('ais-mmsi');
        const pAisNom = document.getElementById('ais-nom');
        const pAisPosition = document.getElementById('ais-position');
        const pAisVitesse = document.getElementById('ais-vitesse');
        const pAisCap = document.getElementById('ais-cap');
        const pAisType = document.getElementById('ais-type');
        const pAisDestination = document.getElementById('ais-destination');
        const pAisEta = document.getElementById('ais-eta');
        let aisCache = new Map(); // Cache pour garder les données AIS par MMSI

        // ✅ Initialiser la carte Leaflet
        let map = L.map('map').setView([48.0, 1.0], 6);  // Position et zoom par défaut
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
        }).addTo(map);

        let marker = null;
        let path = [];
        let polyline = L.polyline([], { color: 'red' }).addTo(map);
        
        function updateMapFromParts(parts, latIndex, latDirIndex, lonIndex, lonDirIndex) {
            const rawLat = parseFloat(parts[latIndex]);
            const latDir = parts[latDirIndex];
            const rawLon = parseFloat(parts[lonIndex]);
            const lonDir = parts[lonDirIndex];

            if (isNaN(rawLat) || isNaN(rawLon)) return;

            const latDD = (Math.floor(rawLat / 100) + (rawLat % 100) / 60) * (latDir === 'S' ? -1 : 1);
            const lonDD = (Math.floor(rawLon / 100) + (rawLon % 100) / 60) * (lonDir === 'W' ? -1 : 1);

            const latlng = [latDD, lonDD];

            if (marker) {
                marker.setLatLng(latlng);
            } else {
                marker = L.marker(latlng).addTo(map);
            }

            path.push(latlng);
            polyline.setLatLngs(path);
            map.setView(latlng, map.getZoom());
        }

        const aisFragmentCache = new Map(); // Cache pour les fragments AIS
        
        // Nettoyer le cache des fragments AIS toutes les 30 secondes
        setInterval(() => {
            aisFragmentCache.clear();
        }, 90000);
        
        socket.on('nmea_data', function(data) {
            
            // ✅ Nettoyage des préfixes de répéteur GPS
            let cleanData = data;
            
            // Supprimer les préfixes courants des répéteurs
            const repeaterPrefixes = [
                /^\$[A-Z]{2,4}\$/,  // $XYZ$, $ABCD$, etc.
                /^\$[0-9]+\$/,      // $123$, etc.
                /^\$[A-Z0-9]+\$/    // Combinaisons alphanumériques
            ];
            
            for (const prefix of repeaterPrefixes) {
                cleanData = cleanData.replace(prefix, '$');
            }
            
            // Afficher la trame nettoyée
            document.getElementById('gpsMessage').textContent = cleanData;

            const parts = cleanData.split(','); // ✅ Utiliser cleanData au lieu of data
            
            //Liste des trames reçues
            const trameId = parts[0]; // ex: $GPGGA, $GPRMC, etc.
            if (!trameTypes.has(trameId)) {
                trameTypes.add(trameId);
                document.getElementById('listeTrames').textContent = Array.from(trameTypes).sort().join(', ');
            }
            
            // Conversion de la latitude au format NN° NN,NNN' N/S
            function convertDMtoDMS_Lat(value, direction) {
                if (isNaN(value)) return "";
                const degrees = Math.floor(value / 100);
                const minutes = value - degrees * 100;
                return myDegLat.format(degrees) + `° ` + myMin.format(minutes) + ` ${direction}`;
            }
            
            // Conversion de la longitude au format NNN° NN,NNN' N/S
            function convertDMtoDMS_Lon(value, direction) {
                if (isNaN(value)) return "";
                const degrees = Math.floor(value / 100);
                const minutes = value - degrees * 100;
                return myDegLon.format(degrees) + `° ` + myMin.format(minutes) + ` ${direction}`;
            }
            // RMC Parser  $GPRMC,193715,A,4805.81126,N,00142.52088,W,000.0,,020725,000.8,E,A*20
            function parseRMC(parts) {
                if (parts[2] !== 'A') return null;
                const heure = parts[1].match(/.{1,2}/g);
                const jour = parts[9].match(/.{1,2}/g);
                return {
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `,
                    lat: convertDMtoDMS_Lat(parseFloat(parts[3]), parts[4]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[5]), parts[6]),
                    speed: parseFloat(parts[7]).toFixed(2) + " knots <small>(" + (parseFloat(parts[7]) * 1.852).toFixed(2) + " km/h)</small>",
                    date: jour[0] + `/` + jour[1] + `/20` + jour[2]
                };
            }
            // GGA Parser
            function parseGGA(parts) {
                if (parts[6] === '0') return null;
                const heure = parts[1].match(/.{1,2}/g);
                return {
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `,
                    lat: convertDMtoDMS_Lat(parseFloat(parts[2]), parts[3]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[4]), parts[5]),
                    alt: parts[9] + " " + parts[10]
                };
            }
            //GLL Parser 
            function parseGLL(parts) {
                const heure = parts[5].match(/.{1,2}/g);
                return {
                    lat: convertDMtoDMS_Lat(parseFloat(parts[1]), parts[2]),
                    lon: convertDMtoDMS_Lon(parseFloat(parts[3]), parts[4]),
                    time: heure[0] + `h ` + heure[1] + `m ` + heure[2] + `s `
                };
            }
            //VTG Parser
            function parseVTG(parts) {
                return {
                    cap: parts[1] + "° True"
                };
            }
            //HDT Parser
            function parseHDT(parts) {
                return {
                    heading: parts[1] + "° True"
                };
            }
            
            // ✅ AIS Parsers
            // Fonction de décodage 6-bit ASCII pour AIS
            function decode6BitAscii(data, start, length) {
                const chars = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?";
                let result = "";
                for (let i = start; i < start + length && i < data.length; i += 6) {
                    const charCode = parseInt(data.substr(i, 6), 2);
                    if (charCode < chars.length && charCode !== 0) {
                        result += chars[charCode];
                    }
                }
                return result.trim();
            }
            
            // Fonction pour décoder les données AIS encapsulées
            function decodeAisPayload(payload) {
                // Décodage 6-bit vers binaire
                let binaryData = "";
                for (let i = 0; i < payload.length; i++) {
                    let char = payload.charCodeAt(i);
                    if (char >= 48 && char <= 87) { // '0' à 'W'
                        char -= 48;
                    } else if (char >= 96 && char <= 119) { // '`' à 'w'  
                        char -= 56;
                    } else {
                        continue;
                    }
                    binaryData += char.toString(2).padStart(6, '0');
                }
                return binaryData;
            }
            
            // Parser principal AIS avec gestion des fragments
            function parseAIS(parts) {
                try {
                    // Structure trame AIS: !AIVDM,totalFragments,currentFragment,sequenceId,channel,payload,fillBits*checksum
                    if (parts.length < 6) return null;
                    
                    const totalFragments = parseInt(parts[1]);
                    const currentFragment = parseInt(parts[2]);
                    const sequenceId = parts[3];
                    const payload = parts[5];
                    
                    // Si c'est un message multi-fragments
                    if (totalFragments > 1) {
                        // Créer une clé unique pour ce message
                        const fragmentKey = `${sequenceId}_${totalFragments}`;
                        
                        // Récupérer ou créer l'entrée pour ce groupe de fragments
                        let fragmentData = aisFragmentCache.get(fragmentKey) || {
                            totalFragments: totalFragments,
                            receivedFragments: new Map(),
                            payload: ''
                        };
                        
                        // Stocker ce fragment
                        fragmentData.receivedFragments.set(currentFragment, payload);
                        
                        // Vérifier si on a tous les fragments
                        if (fragmentData.receivedFragments.size === totalFragments) {
                            // Reconstituer le payload complet dans l'ordre
                            let completePayload = '';
                            for (let i = 1; i <= totalFragments; i++) {
                                completePayload += fragmentData.receivedFragments.get(i) || '';
                            }
                            
                            // Nettoyer le cache
                            aisFragmentCache.delete(fragmentKey);
                            
                            // Traiter le message complet
                            return parseCompleteAISMessage(completePayload);
                        } else {
                            // Sauvegarder les fragments en attente
                            aisFragmentCache.set(fragmentKey, fragmentData);
                            return null; // Pas encore complet
                        }
                    } else {
                        // Message en un seul fragment
                        return parseCompleteAISMessage(payload);
                    }
                } catch (error) {
                    console.log("Erreur parsing AIS fragments:", error);
                    return null;
                }
            }
            
            // Fonction pour parser un message AIS complet
            function parseCompleteAISMessage(payload) {
                try {
                    const binaryData = decodeAisPayload(payload);
                    
                    if (binaryData.length < 8) return null;
                    
                    // Type de message (bits 0-5)
                    const messageType = parseInt(binaryData.substr(0, 6), 2);
                    
                    // MMSI (bits 8-37)
                    const mmsi = parseInt(binaryData.substr(8, 30), 2);
                    
                    let result = {
                        messageType: messageType,
                        mmsi: mmsi.toString()
                    };
                    
                    // Type 1, 2, 3: Position Report
                    if (messageType >= 1 && messageType <= 3 && binaryData.length >= 168) {
                        const navStatus = parseInt(binaryData.substr(38, 4), 2);
                        const rot = parseInt(binaryData.substr(42, 8), 2);
                        const sog = parseInt(binaryData.substr(50, 10), 2) / 10;
                        const lon = parseInt(binaryData.substr(61, 28), 2);
                        const lat = parseInt(binaryData.substr(89, 27), 2);
                        const cog = parseInt(binaryData.substr(116, 12), 2) / 10;
                        const heading = parseInt(binaryData.substr(128, 9), 2);
                        
                        // Conversion coordonnées
                        const longitude = (lon > 134217727) ? (lon - 268435456) / 600000 : lon / 600000;
                        const latitude = (lat > 67108863) ? (lat - 134217728) / 600000 : lat / 600000;
                        
                        result.latitude = latitude.toFixed(6);
                        result.longitude = longitude.toFixed(6);
                        result.sog = sog.toFixed(1);
                        result.cog = cog.toFixed(1);
                        result.heading = heading !== 511 ? heading.toString() : "N/A";
                        result.status = getNavStatus(navStatus);
                        
                        console.log(`AIS Position (Type ${messageType}): MMSI ${mmsi}, ${latitude.toFixed(6)}, ${longitude.toFixed(6)}`);
                    }
                    
                    // Type 5: Static and Voyage Related Data (messages complets maintenant!)
                    if (messageType === 5 && binaryData.length >= 424) {
                        const vesselName = decode6BitAscii(binaryData, 112, 120).replace(/@/g, '').trim();
                        const shipType = parseInt(binaryData.substr(232, 8), 2);
                        const destination = decode6BitAscii(binaryData, 302, 120).replace(/@/g, '').trim();
                        const etaMonth = parseInt(binaryData.substr(274, 4), 2);
                        const etaDay = parseInt(binaryData.substr(278, 5), 2);
                        const etaHour = parseInt(binaryData.substr(283, 5), 2);
                        const etaMinute = parseInt(binaryData.substr(288, 6), 2);
                        
                        result.vesselName = vesselName;
                        result.shipType = getShipType(shipType);
                        result.destination = destination;
                        if (etaMonth > 0 && etaDay > 0) {
                            result.eta = `${etaDay}/${etaMonth} ${etaHour}:${etaMinute.toString().padStart(2, '0')}`;
                        }
                        
                        console.log(`AIS Static Data (Type 5): MMSI ${mmsi}, Nom: "${vesselName}", Type: ${getShipType(shipType)}, Destination: "${destination}"`);
                    }
                    
                    return result;
                } catch (error) {
                    console.log("Erreur parsing message AIS complet:", error);
                    return null;
                }
            }
            
            // Fonction utilitaire pour le statut de navigation
            function getNavStatus(status) {
                const statuses = [
                    "Under way using engine",
                    "At anchor",
                    "Not under command",
                    "Restricted manoeuvrability",
                    "Constrained by her draught",
                    "Moored",
                    "Aground",
                    "Engaged in fishing",
                    "Under way sailing",
                    "Reserved for HSC",
                    "Reserved for WIG",
                    "Reserved",
                    "Reserved",
                    "Reserved",
                    "AIS-SART",
                    "Undefined"
                ];
                return statuses[status] || "Unknown";
            }
            
            // Fonction utilitaire pour le type de navire
            function getShipType(type) {
                if (type >= 20 && type <= 29) return "Wing in ground";
                if (type >= 30 && type <= 39) return "Fishing";
                if (type >= 40 && type <= 49) return "Tug";
                if (type >= 50 && type <= 59) return "Medical";
                if (type >= 60 && type <= 69) return "Passenger";
                if (type >= 70 && type <= 79) return "Cargo";
                if (type >= 80 && type <= 89) return "Tanker";
                if (type >= 90 && type <= 99) return "Other";
                return "Unknown";
            }
            /* To Do: Parser MDA, MMB, XDR, HDG
            ✅ AIS support ajouté (AIVDM/AIVDO)
            */
            var myDegLat = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 2, 
                minimumFractionDigits: 0 
            });
            
            var myDegLon = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 3, 
                minimumFractionDigits: 0 
            });
            
            var myMin = new Intl.NumberFormat('en-US', { 
                minimumIntegerDigits: 2, 
                minimumFractionDigits: 3 
            });
            
            function clearHighlightClasses(...elements) {
                elements.forEach(el => {
                    el.classList.remove('gga', 'rmc', 'gll', 'ais', 'defaut');
                });
            }
                        
            if (cleanData.substring(3,6) === 'RMC') {
                clearHighlightClasses(pDate, pHeure, pLat, pLong, pVitesse);
                pDate.classList.add('rmc');
                pHeure.classList.add('rmc');
                pLat.classList.add('rmc');
                pLong.classList.add('rmc');
                pVitesse.classList.add('rmc');
                const parsed = parseRMC(parts);
                if (parsed) {
                    // Mise à jour des champs texte...
                    pDate.innerHTML = "Date : " + parsed.date;
                    pHeure.innerHTML = "Heure UTC : " + parsed.time;
                    pLat.innerHTML = "Latitude : " + parsed.lat;
                    pLong.innerHTML = "Longitude : " + parsed.lon;
                    pVitesse.innerHTML = "Vitesse : " + parsed.speed;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 3, 4, 5, 6); // lat, latDir, lon, lonDir
                }
            } else if (cleanData.substring(3,6) === 'GGA') {
                clearHighlightClasses(pHeure, pLat, pLong, pAlt);
                pHeure.classList.add('gga');
                pLat.classList.add('gga');
                pLong.classList.add('gga');
                pAlt.classList.add('gga');
                const parsed = parseGGA(parts);
                if (parsed) {
                    pHeure.innerHTML = "Heure UTC : " + parsed.time;
                    pLat.innerHTML = "Latitude : " + parsed.lat;
                    pLong.innerHTML = "Longitude : " + parsed.lon;
                    pAlt.innerHTML = "Altitude : " + parsed.alt;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 2, 3, 4, 5);
                }
            } else if (cleanData.substring(3,6) === 'GLL') {
                clearHighlightClasses(pHeure, pLat, pLong);
                pHeure.classList.add('gll');
                pLat.classList.add('gll');
                pLong.classList.add('gll');
                const parsed = parseGLL(parts);
                if (parsed) {
                    pHeure.innerHTML = "Heure UTC : " + parsed.time;
                    pLat.innerHTML = "Latitude : " + parsed.lat;
                    pLong.innerHTML = "Longitude : " + parsed.lon;
                    // ✅ Mise à jour carte
                    updateMapFromParts(parts, 1, 2, 3, 4);
                }
            } else if (cleanData.substring(3,6) === 'VTG') {
                const parsed = parseVTG(parts);
                if (parsed) {
                    document.getElementById('cap').textContent = "Route fond : " + parsed.cap;
                }
            } else if (cleanData.substring(3,6) === 'HDT') {
                const parsed = parseHDT(parts);
                if (parsed) {
                    document.getElementById('heading').textContent = "Cap : " + parsed.heading;
                }
            } else if (cleanData.substring(1,6) === 'AIVDM' || cleanData.substring(1,6) === 'AIVDO') {
                // ✅ Traitement AIS amélioré avec cache
                const parsed = parseAIS(parts);
                if (parsed && parsed.mmsi) {
                    // Récupérer ou créer l'entrée cache pour ce MMSI
                    let vessel = aisCache.get(parsed.mmsi) || { mmsi: parsed.mmsi };
                    
                    // Fusionner les nouvelles données avec les existantes
                    Object.assign(vessel, parsed);
                    
                    // Sauvegarder dans le cache
                    aisCache.set(parsed.mmsi, vessel);
                    
                    // ✅ Afficher les données du navire le plus récent (ou spécifique)
                    displayAISData(vessel);
                    
                    // ✅ Mettre à jour la carte si on a une position
                    if (vessel.latitude && vessel.longitude) {
                        updateAISOnMap(vessel);
                    }
                };
            };
    
    
            // ✅ Nouvelle fonction pour afficher les données AIS
            function displayAISData(vessel) {
                clearHighlightClasses(pAisMmsi, pAisNom, pAisPosition, pAisVitesse, pAisCap, pAisType, pAisDestination, pAisEta);
                pAisMmsi.classList.add('ais');
                pAisNom.classList.add('ais');
                pAisPosition.classList.add('ais');
                pAisVitesse.classList.add('ais');
                pAisCap.classList.add('ais');
                pAisType.classList.add('ais');
                pAisDestination.classList.add('ais');
                pAisEta.classList.add('ais');
                
                // Afficher toutes les données avec valeurs par défaut si manquantes
                pAisMmsi.textContent = "MMSI : " + (vessel.mmsi || "En attente...");
                
                pAisNom.textContent = "Navire : " + (vessel.vesselName || "En attente du nom...");
                
                if (vessel.latitude && vessel.longitude) {
                    pAisPosition.textContent = `Position : ${vessel.latitude}°, ${vessel.longitude}°`;
                } else {
                    pAisPosition.textContent = "Position : En attente...";
                }
                
                if (vessel.sog && vessel.sog !== "0.0") {
                    pAisVitesse.textContent = "Vitesse AIS : " + vessel.sog + " nœuds (" + (vessel.sog * 1.852).toFixed(1) + " km/h)";
                } else {
                    pAisVitesse.textContent = "Vitesse AIS : En attente...";
                }
                
                if (vessel.cog && vessel.cog !== "0.0") {
                    pAisCap.textContent = "Route AIS : " + vessel.cog + "°";
                } else {
                    pAisCap.textContent = "Route AIS : En attente...";
                }
                
                pAisType.textContent = "Type : " + (vessel.shipType || "En attente...");
                
                pAisDestination.textContent = "Destination : " + (vessel.destination || "En attente...");
                
                pAisEta.textContent = "ETA : " + (vessel.eta || "En attente...");
                
                // ✅ Mettre à jour la liste directement ici (plus simple)
                updateVesselList();
            }

            // ✅ Nouvelle fonction pour mettre à jour la carte AIS
            function updateAISOnMap(vessel) {
                const lat = parseFloat(vessel.latitude);
                const lon = parseFloat(vessel.longitude);
                
                if (!isNaN(lat) && !isNaN(lon)) {
                    // Utiliser le nom du navire si disponible, sinon les 4 derniers chiffres du MMSI
                    const displayName = vessel.vesselName || `${vessel.mmsi.slice(-4)}`;
                    
                    const shipIcon = L.divIcon({
                        className: 'ship-icon',
                        html: `<div style="background: #e91e63; color: white; border-radius: 3px; padding: 2px 5px; font-size: 10px; font-weight: bold; max-width: 120px; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayName}</div>`,
                        iconSize: [120, 20],
                        iconAnchor: [60, 10]
                    });
                    
                    // Supprimer les anciens marqueurs de navires pour ce MMSI
                    map.eachLayer(layer => {
                        if (layer.options && layer.options.mmsi === vessel.mmsi) {
                            map.removeLayer(layer);
                        }
                    });
                    
                    // Ajouter nouveau marqueur avec toutes les infos disponibles
                    L.marker([lat, lon], { 
                        icon: shipIcon, 
                        mmsi: vessel.mmsi 
                    }).addTo(map).bindPopup(`
                        <b>MMSI:</b> ${vessel.mmsi}<br>
                        ${vessel.vesselName ? `<b>Nom:</b> ${vessel.vesselName}<br>` : '<b>Nom:</b> En attente...<br>'}
                        ${vessel.sog ? `<b>Vitesse:</b> ${vessel.sog} nœuds<br>` : ''}
                        ${vessel.cog ? `<b>Route:</b> ${vessel.cog}°<br>` : ''}
                        ${vessel.heading && vessel.heading !== "N/A" ? `<b>Cap:</b> ${vessel.heading}°<br>` : ''}
                        ${vessel.status ? `<b>Statut:</b> ${vessel.status}<br>` : ''}
                        ${vessel.shipType ? `<b>Type:</b> ${vessel.shipType}<br>` : ''}
                        ${vessel.destination ? `<b>Destination:</b> ${vessel.destination}<br>` : ''}
                        ${vessel.eta ? `<b>ETA:</b> ${vessel.eta}` : ''}
                    `);
                }
            }
            

            //fonction pour mettre à jour la liste des navires

            function updateVesselList() {
                const vesselList = document.getElementById('vessel-list');
                if (aisCache.size === 0) {
                    vesselList.innerHTML = '<p>Aucun navire détecté pour le moment...</p>';
                    return;
                }
                
                let html = '';
                aisCache.forEach((vessel, mmsi) => {
                    const name = vessel.vesselName || 'Nom inconnu';
                    const position = vessel.latitude && vessel.longitude ? 
                        `${vessel.latitude}°, ${vessel.longitude}°` : 'Position inconnue';
                    const lastUpdate = new Date().toLocaleTimeString();
                    
                    html += `
                        <div style="border: 1px solid #333; margin: 5px 0; padding: 10px; border-radius: 5px; cursor: pointer;" 
                            onclick="displayAISData(aisCache.get('${mmsi}'))">
                            <strong>${name}</strong> (MMSI: ${mmsi})<br>
                            <small>${position} - Mis à jour: ${lastUpdate}</small>
                        </div>
                    `;
                });
                
                vesselList.innerHTML = html;
            }
        });
    </script>
  </body>
</html>